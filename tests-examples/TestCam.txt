import json
import paho.mqtt.client as mqtt
from pyzeebe import ZeebeClient, create_insecure_channel
import asyncio
import threading

# --- Configuration ---
PROCESS_ID = "temp-process"
# Define the address of the Zeebe gRPC gateway.
ZEEBE_ADDRESS = "localhost:26500"
BROKER_ADDRESS = "192.168.1.146"
MQTT_PORT = 1883
MQTT_TOPIC = "tfg/sensors/temp"

# --- Producer-Consumer Queue ---
# Create an asynchronous queue to act as a thread-safe buffer between the MQTT and Zeebe clients.
message_queue = asyncio.Queue()

# Define the main asynchronous function that will consume messages from the queue.
async def process_starter():
    channel = create_insecure_channel(grpc_address=ZEEBE_ADDRESS)
    zeebe_client = ZeebeClient(channel)
    print("Zeebe process starter is running...")

    # Start an infinite loop to continuously process messages.
    while True:
        try:
            # Asynchronously wait for and retrieve the next item from the message queue.
            variables = await message_queue.get()
            
            print(f"Starting process '{PROCESS_ID}' with variables: {variables}")
            # Asynchronously request the Zeebe client to start a new process instance with the given ID and variables.
            await zeebe_client.run_process(PROCESS_ID, variables=variables)
            print("Process started successfully.")
            
            # Signal to the queue that the retrieved item has been fully processed.
            message_queue.task_done()
        except Exception as e:
            print(f"Error starting Camunda process: {e}")

# --- Background asyncio loop setup ---
# Define a function that will run the asyncio event loop. This will be the target for our background thread.
def start_asyncio_loop(loop):
    # Set the event loop for the current thread.
    asyncio.set_event_loop(loop)
    # Run the event loop forever, processing async tasks.
    loop.run_forever()

# Create a new asyncio event loop object for the background thread.
async_loop = asyncio.new_event_loop()
# Safely schedule the `process_starter` coroutine to run on the background event loop.
asyncio.run_coroutine_threadsafe(process_starter(), async_loop)

# Create a new thread object.
loop_thread = threading.Thread(target=start_asyncio_loop, args=(async_loop,))
# Set the thread as a daemon, so it exits when the main program exits.
loop_thread.daemon = True
# Start the background thread, which will run the `start_asyncio_loop` function.
loop_thread.start()

# --- MQTT Callback ---
def on_message(client, userdata, msg):
    print(f"Received on {msg.topic}: {msg.payload.decode()}")
    try:
        payload = json.loads(msg.payload.decode())
        variables = {"temperature": payload.get("value")}
        async_loop.call_soon_threadsafe(message_queue.put_nowait, variables)
    except Exception as e:
        print(f"Error handling message: {e}")


mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1) # Specify API version to remove warning
mqtt_client.on_message = on_message
mqtt_client.connect(BROKER_ADDRESS, MQTT_PORT, 60)
mqtt_client.subscribe(MQTT_TOPIC)

print(f"Subscribed to topic '{MQTT_TOPIC}'. Waiting for messages...")
try:
    mqtt_client.loop_forever()
except KeyboardInterrupt:
    print("\nShutting down...")
finally:
    mqtt_client.disconnect()
    if async_loop.is_running():
        async_loop.call_soon_threadsafe(async_loop.stop)
    print("Shutdown complete.")